{"whiteboard": "", "video_mp4_download_only": true, "video_webm_download_only": false, "duration": 30, "video_ogv_download_only": false, "category": "PyCon AU 2013", "speakers": ["Erik van Zijst"], "title": "Limiting Execution Time Through Interrupt Driven Programming", "quality_notes": "", "video_flv_length": null, "recorded": "2013-07-06", "video_mp4_length": null, "description": "", "video_mp4_url": "http://s3.us.archive.org/ndvpyconau2013/Limiting_Execution_Time_Throug.mp4", "tags": [], "copyright_text": "CC-BY-SA", "related_urls": [], "video_flv_download_only": false, "source_url": "https://www.youtube.com/watch?v=Hv2pl7B1pZw", "video_webm_url": null, "video_ogv_length": null, "video_ogv_url": null, "language": "English", "video_webm_length": null, "summary": "This talk explores the challenges of ensuring responsiveness of applications under varying conditions like suddenly increased load, code regressions and problematic user data that reveal code paths with unusually high time complexity.\r\n\r\nI'll be looking at interrupt-driven techniques to help bring the 95 percentile of the response times of your application closer to the (usually much lower) mean.\r\n\r\nIn this talk, we'll go beyond traditional tricks like caching, sharding and data denormalization and instead look at tools that can interrupt execution of overly expensive code paths, such that you can guarantee an upper bound in response time.\r\n\r\nInterruptingcow and django-timelimit will be some of the tools that will be covered in this talk.\r\n\r\nThe context for most of this is web applications, and I'll be drawing many examples from our ongoing experiences with running and scaling Bitbucket, which is entirely written in Python.\r\n\r\nHaving said that though, many of the tools and techniques demonstrates will apply just as well to other types of applications and situations.\r\n", "thumbnail_url": "http://i1.ytimg.com/vi/Hv2pl7B1pZw/hqdefault.jpg", "video_flv_url": null}